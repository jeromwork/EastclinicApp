# Уточнения и решения: Step 0 — Contract skeleton

**Дата**: 2025-01-27

## (1) Модули и границы

### Q1.1: Структура feature:* модулей
**Вопрос**: Как именно структурированы feature:* модули? Каждый feature — это один модуль с подпапками или отдельные модули для каждого слоя?

**Варианты**:
- A) Один модуль `feature:auth` с подпапками `presentation/`, `domain/`, `data/`
- B) Три отдельных модуля: `feature:auth:presentation`, `feature:auth:domain`, `feature:auth:data`
- C) Два модуля: `feature:auth:ui` (presentation) и `feature:auth:core` (domain+data вместе)

**Рекомендация**: Вариант B — три отдельных модуля. Это обеспечивает строгие границы зависимостей на уровне Gradle, предотвращает случайные нарушения архитектуры и соответствует принципам Clean Architecture.

---

### Q1.2: Размещение базовых типов
**Вопрос**: В каком модуле находятся базовые типы (AppError, Result<T>, DispatcherProvider, Clock)?

**Варианты**:
- A) Все в `core:common`
- B) AppError и Result<T> в `core:common`, DispatcherProvider и Clock в отдельном `core:coroutines` или `core:async`
- C) AppError и Result<T> в `core:common`, DispatcherProvider и Clock в `core:ui` (так как используются в ViewModel)

**Рекомендация**: Вариант A — все в `core:common`. Это централизует фундаментальные абстракции, упрощает зависимости и соответствует принципу "common для всего общего".

---

### Q1.3: Зависимости между core модулями
**Вопрос**: Какие зависимости разрешены между core модулями?

**Варианты**:
- A) Только `core:*` → `core:common` (все core модули могут зависеть от common, но не друг от друга)
- B) `core:ui` → `core:common`, `core:network` → `core:common`, `core:auth` → `core:common` и `core:network` (auth может использовать network)
- C) Любые зависимости между core модулями, кроме циклических

**Рекомендация**: Вариант A — только к `core:common`. Это минимизирует связанность, упрощает тестирование и предотвращает циклические зависимости.

---

### Q1.4: Зависимости app модуля
**Вопрос**: Может ли `app` модуль напрямую зависеть от feature модулей, или только через navigation/DI?

**Варианты**:
- A) `app` может напрямую зависеть от `feature:*:presentation` для регистрации экранов в навигации
- B) `app` зависит только от core модулей, feature модули регистрируются через DI/рефлексию
- C) `app` зависит от всех feature модулей напрямую

**Рекомендация**: Вариант A — `app` зависит от `feature:*:presentation` для навигации. Это стандартный подход в Android, позволяет compile-time проверку навигации и не нарушает изоляцию feature модулей (app — это композиционный модуль).

---

**Ваши ответы (1.1, 1.2, 1.3, 1.4):**
```
[Оставьте место для ответов]
```

---

## (2) Навигация и графы

### Q2.1: Библиотека навигации
**Вопрос**: Какая библиотека/подход используется для навигации?

**Варианты**:
- A) Navigation Component (androidx.navigation) для View-based UI
- B) Compose Navigation (androidx.navigation.compose) для Jetpack Compose
- C) Кастомное решение на основе Router/Navigator интерфейсов

**Рекомендация**: Зависит от UI фреймворка. Если Compose — вариант B, если View — вариант A. Для MVP с учетом конституции (минимальная сложность) — Navigation Component.

---

### Q2.2: Расположение графа навигации
**Вопрос**: Где определяется граф навигации (routes, destinations)?

**Варианты**:
- A) В `app` модуле — централизованный граф со всеми экранами
- B) В `core:ui` — общий граф навигации
- C) В каждом `feature:*:presentation` — свой подграф, композиция в `app`

**Рекомендация**: Вариант C — подграфы в feature модулях, композиция в app. Это соответствует изоляции feature модулей и позволяет независимую разработку.

---

### Q2.3: Регистрация экранов feature модулей
**Вопрос**: Как feature модули регистрируют свои экраны в граф навигации?

**Варианты**:
- A) Через публичные константы/объекты с route строками, которые импортируются в app
- B) Через интерфейс `NavigationContributor`, который реализует каждый feature и регистрируется в app через DI
- C) Через аннотации/кодогенерацию

**Рекомендация**: Вариант A для MVP (простота), вариант B для масштабируемости. Для Step 0 — вариант A (минимальная сложность).

---

### Q2.4: Навигация между feature модулями
**Вопрос**: Как feature модули навигируют друг к другу без прямых зависимостей?

**Варианты**:
- A) Через строковые route в `core:ui`, которые знают все feature модули
- B) Через интерфейс `NavigationCommand` в `core:ui`, который реализует app
- C) Через события UiEffect.Navigate, которые обрабатывает app модуль

**Рекомендация**: Вариант A для MVP — простые строковые route в `core:ui` или `core:common`. Это минимальная сложность и соответствует конституции.

---

**Ваши ответы (2.1, 2.2, 2.3, 2.4):**
```
[Оставьте место для ответов]
```

---

## (3) Dependency Injection (DI)

### Q3.1: Библиотека DI
**Вопрос**: Какая библиотека DI используется?

**Варианты**:
- A) Hilt (рекомендуемый Google для Android)
- B) Koin (легковесная, Kotlin-first)
- C) Manual DI (ручное создание графа зависимостей)

**Рекомендация**: Вариант A — Hilt. Это стандарт для Android, хорошо интегрируется с Navigation Component, поддерживает multi-module проекты и обеспечивает compile-time проверку.

---

### Q3.2: Размещение DI модулей
**Вопрос**: Где находятся DI модули (Hilt modules / Koin modules)?

**Варианты**:
- A) В каждом модуле свой DI модуль (feature:auth имеет AuthModule, core:network имеет NetworkModule)
- B) Все DI модули в `app` модуле
- C) Core модули имеют свои DI модули, feature модули регистрируются в app

**Рекомендация**: Вариант A — каждый модуль предоставляет свой DI модуль. Это соответствует принципу инкапсуляции и позволяет независимую разработку модулей.

---

### Q3.3: Application класс
**Вопрос**: Где находится Application класс с инициализацией DI?

**Варианты**:
- A) В `app` модуле
- B) В `core:common` (но это нарушает Android-зависимости)
- C) Application класс в app, но базовые интерфейсы DI в core:common

**Рекомендация**: Вариант A — Application класс в `app` модуле. Это стандартное место для Android приложений.

---

**Ваши ответы (3.1, 3.2, 3.3):**
```
[Оставьте место для ответов]
```

---

## (4) core:network контракт

### Q4.1: Интерфейсы в core:network
**Вопрос**: Какие интерфейсы/контракты должны быть определены в `core:network`?

**Варианты**:
- A) Только базовые интерфейсы: `NetworkClient`, `Request`, `Response` (абстракция над HTTP)
- B) Более специфичные: `ApiClient`, `NetworkCall<T>`, `NetworkError` (ближе к Retrofit, но без реализации)
- C) Минимальный контракт: только `NetworkError` как часть AppError, остальное в domain интерфейсах

**Рекомендация**: Вариант A — базовые интерфейсы для HTTP клиента. Это обеспечивает абстракцию без привязки к конкретной реализации (Retrofit/OkHttp/Ktor).

---

### Q4.2: Использование network в feature модулях
**Вопрос**: Как feature модули используют сетевые запросы?

**Варианты**:
- A) Domain слой определяет интерфейсы (например, `AuthRepository`), data слой реализует через `core:network`
- B) `core:network` предоставляет готовые интерфейсы для API, которые используют data слои
- C) Feature модули напрямую используют `core:network` в data слое

**Рекомендация**: Вариант A — domain определяет интерфейсы, data реализует через core:network. Это соответствует Clean Architecture и конституции (domain не знает о network).

---

**Ваши ответы (4.1, 4.2):**
```
[Оставьте место для ответов]
```

---

## (5) Шаблон feature модуля

### Q5.1: Структура пакетов feature модуля
**Вопрос**: Какая структура пакетов должна быть в feature модуле (например, feature:auth)?

**Варианты**:
- A) По слоям: `com.eastclinic.auth.presentation`, `com.eastclinic.auth.domain`, `com.eastclinic.auth.data`
- B) По компонентам: `com.eastclinic.auth.login`, `com.eastclinic.auth.register` (каждый со своими presentation/domain/data)
- C) Гибрид: `com.eastclinic.auth.domain` (общий), `com.eastclinic.auth.login.presentation`, `com.eastclinic.auth.login.data`

**Рекомендация**: Вариант A — по слоям. Это стандарт для Clean Architecture, упрощает навигацию по коду и соответствует разделению ответственности.

---

### Q5.2: Шаблон для нового feature
**Вопрос**: Должен ли быть создан шаблон/архетип для быстрого создания нового feature модуля?

**Варианты**:
- A) Да, Gradle template или скрипт для генерации структуры feature модуля
- B) Нет, достаточно документации с примером
- C) Частично — только структура папок, код пишется вручную

**Рекомендация**: Вариант C для MVP — структура папок + документация. Полная генерация кода может быть добавлена позже, если понадобится.

---

**Ваши ответы (5.1, 5.2):**
```
[Оставьте место для ответов]
```

---

## (6) Базовые типы ошибок и Result

### Q6.1: Структура AppError
**Вопрос**: Какая структура у AppError? Это sealed class с конкретными типами ошибок или базовый класс?

**Варианты**:
- A) Sealed class с типами: `NetworkError`, `ValidationError`, `UnknownError` и т.д.
- B) Базовый класс/интерфейс с кодом и сообщением, конкретные типы в feature модулях
- C) Enum с основными типами + расширяемый через sealed class

**Рекомендация**: Вариант A — sealed class с основными типами. Это type-safe, позволяет exhaustive when и соответствует Kotlin best practices.

---

### Q6.2: Структура Result<T>
**Вопрос**: Какая структура у Result<T>?

**Варианты**:
- A) Sealed class: `Result.Success<T>(data: T)` и `Result.Error(error: AppError)`
- B) Класс с полями: `data class Result<T>(val data: T?, val error: AppError?)`
- C) Использовать готовую библиотеку (например, Arrow, Kotlin Result)

**Рекомендация**: Вариант A — sealed class. Это стандартный подход в Kotlin, type-safe и не требует внешних зависимостей.

---

### Q6.3: Расширяемость ошибок
**Вопрос**: Могут ли feature модули добавлять свои типы ошибок?

**Варианты**:
- A) Нет, все типы ошибок определены в `core:common`
- B) Да, feature модули могут расширять AppError через sealed class hierarchy
- C) Да, через композицию — feature модули определяют свои ошибки, которые маппятся в AppError

**Рекомендация**: Вариант C — композиция. Feature модули определяют свои доменные ошибки, data слой маппит их в AppError. Это сохраняет изоляцию feature модулей.

---

**Ваши ответы (6.1, 6.2, 6.3):**
```
[Оставьте место для ответов]
```

---

## (7) UI-state (UiState/UiEvent/UiEffect)

### Q7.1: Базовые классы/интерфейсы
**Вопрос**: Должны ли UiState, UiEvent, UiEffect быть базовыми классами/интерфейсами в `core:ui` или каждый feature определяет свои?

**Варианты**:
- A) Базовые интерфейсы/классы в `core:ui`, feature модули наследуют/реализуют
- B) Только конвенция (документация), каждый feature определяет свои классы
- C) Базовые sealed class в `core:ui` с общими типами (например, `UiEffect.Navigate`, `UiEffect.ShowToast`)

**Рекомендация**: Вариант C — базовые sealed class с общими типами эффектов. Это обеспечивает консистентность навигации и общих UI действий, но позволяет feature модулям расширять.

---

### Q7.2: Базовый ViewModel
**Вопрос**: Должен ли быть базовый класс BaseViewModel в `core:ui`?

**Варианты**:
- A) Да, `BaseViewModel<UiState, UiEvent, UiEffect>` с общим функционалом
- B) Нет, только интерфейс/контракт, каждый feature реализует свой ViewModel
- C) Частично — только утилиты/extension функции, не базовый класс

**Рекомендация**: Вариант A — базовый класс. Это уменьшает дублирование кода, обеспечивает консистентность обработки StateFlow/SharedFlow и соответствует DRY принципу.

---

### Q7.3: Обработка UiEffect
**Вопрос**: Как обрабатываются UiEffect в UI слое (Compose/View)?

**Варианты**:
- A) Через `LaunchedEffect` в Compose или `lifecycleScope.launch` в View, подписка на SharedFlow
- B) Через callback/lambda, которую передает ViewModel
- C) Через единый обработчик в базовом Activity/Fragment

**Рекомендация**: Вариант A — подписка на SharedFlow через LaunchedEffect/lifecycleScope. Это соответствует reactive подходу и стандартам Android.

---

**Ваши ответы (7.1, 7.2, 7.3):**
```
[Оставьте место для ответов]
```

---

## (8) Тестовая стратегия MVP

### Q8.1: Минимальный набор тестов для Step 0
**Вопрос**: Какие тесты обязательны для Step 0?

**Варианты**:
- A) Только unit тесты для базовых типов (AppError, Result<T>)
- B) Unit тесты для базовых типов + интеграционные тесты для проверки зависимостей модулей
- C) Unit тесты + интеграционные тесты + UI тесты для навигации между stub экранами

**Рекомендация**: Вариант B — unit тесты для базовых типов + интеграционные тесты для модульной структуры. UI тесты можно отложить до реальных фич.

---

### Q8.2: Тестирование ViewModel
**Вопрос**: Должны ли stub экраны иметь тесты ViewModel?

**Варианты**:
- A) Да, хотя бы один пример теста ViewModel для демонстрации паттерна
- B) Нет, тесты ViewModel будут добавлены с реальными фичами
- C) Только тесты базового ViewModel, не stub экранов

**Рекомендация**: Вариант A — хотя бы один пример. Это устанавливает паттерн тестирования и демонстрирует, как тестировать UiState/UiEvent/UiEffect.

---

### Q8.3: Тестовые утилиты
**Вопрос**: Должны ли быть созданы тестовые утилиты (test fixtures) в Step 0?

**Варианты**:
- A) Да, базовые test fixtures для создания тестовых экземпляров AppError, Result, моки DispatcherProvider
- B) Нет, тестовые утилиты будут добавляться по мере необходимости
- C) Частично — только для базовых типов (AppError, Result)

**Рекомендация**: Вариант A — базовые test fixtures. Это ускоряет написание тестов в будущем и обеспечивает консистентность тестовых данных.

---

**Ваши ответы (8.1, 8.2, 8.3):**
```
[Оставьте место для ответов]
```

---

## Итоговый список решений

После получения всех ответов, решения будут внесены в `spec.md` в секцию "Clarifications / Decisions".

